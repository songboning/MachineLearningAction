# -*- coding: utf-8 -*-
"""
Created on Sat Dec 23 17:45:18 2017
矩阵奇异值分解应用模板
@author: Burning
"""

import numpy as np
from numpy import linalg as la

def 载入样例():
    return[[0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5],
           [0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 3],
           [0, 0, 0, 0, 4, 0, 0, 1, 0, 4, 0],
           [3, 3, 4, 0, 0, 0, 0, 2, 2, 0, 0],
           [5, 4, 5, 0, 0, 0, 0, 5, 5, 0, 0],
           [0, 0, 0, 0, 5, 0, 1, 0, 0, 5, 0],
           [4, 3, 4, 0, 0, 0, 0, 5, 5, 0, 1],
           [0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 4],
           [0, 0, 0, 2, 0, 2, 5, 0, 0, 1, 2],
           [0, 0, 0, 0, 5, 0, 0, 0, 0, 4, 0],
           [1, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0]]
#假设[i,j]表示用户i对物品j的打分

def Euclid相似度(列矢量A, 列矢量B):
    return 1 / (1 + la.norm(列矢量A - 列矢量B))#用默认范数表示距离

def pearson相似度(列矢量A, 列矢量B):
    if len(列矢量A) < 3:return 1
    return 0.5 + 0.5 * np.corrcoef(列矢量A, 列矢量B, rowvar=False)[0,1]

def 余弦相似度(列矢量A, 列矢量B):
    return 0.5 + 0.5 * (float(列矢量A.T * 列矢量B) / la.norm(列矢量A) / la.norm(列矢量B))

def 相似度估计(数据矩阵, 用户, 相似度函数, 物品):
    物品数 = np.shape(数据矩阵)[1]
    总相似度 = 0
    总加权相似度 = 0
    for i in range(物品数):
        用户打分 = 数据矩阵[用户, i]
        if not 用户打分:
            continue
        重合用户 = np.nonzero(np.logical_and(数据矩阵[:,物品].A>0, 数据矩阵[:,i].A>0))[0]
        if not len(重合用户):#这个len不能省,否则只包含用户0会被过滤掉
            物品相似度 = 0
        else:
            物品相似度 = 相似度函数(数据矩阵[重合用户, 物品], 数据矩阵[重合用户, i])
        #print(物品,i,物品相似度)
        总相似度 += 物品相似度
        总加权相似度 += 物品相似度 * 用户打分
    if not 总相似度:
        return 0
    return 总加权相似度 / 总相似度
#数据矩阵每行是一个用户打分,每列是一个物品得分

def 奇异值估计(数据矩阵, 用户, 相似度函数, 物品, 奇异值保留数=4):
    物品数 = np.shape(数据矩阵)[1]
    总相似度 = 0
    总加权相似度 = 0
    输入酉矩阵, 对角奇异值矩阵, 输出酉矩阵 = la.svd(数据矩阵)
    主要奇异值矩阵 = np.mat(np.eye(奇异值保留数) * 对角奇异值矩阵[:奇异值保留数])
    异化物品 = 数据矩阵.T * 输入酉矩阵[:, :奇异值保留数] * 主要奇异值矩阵.I
    for i in range(物品数):
        用户打分 = 数据矩阵[用户, i]
        if not 用户打分 or i == 物品:
            continue
        物品相似度 = 相似度函数(异化物品[物品, :].T, 异化物品[i, :].T)
        #print(物品,i,物品相似度)
        总相似度 += 物品相似度
        总加权相似度 += 物品相似度 * 用户打分
    if not 总相似度:
        return 0
    return 总加权相似度 / 总相似度

def 推荐(数据矩阵, 用户, 推荐数=3, 相似度函数=余弦相似度, 估计函数=相似度估计):
    未打分物品 = np.nonzero(数据矩阵[用户, :].A == 0)[1]
    if not len(未打分物品):
        return '用户已了解所有物品'
    物品推荐情况 = []
    for 物品 in 未打分物品:
        估计推荐度 = 估计函数(数据矩阵, 用户, 相似度函数, 物品)
        物品推荐情况.append((物品, 估计推荐度))
    return sorted(物品推荐情况, key=lambda x:x[1], reverse=True)[:推荐数]

def 二值化打印矩阵(矩阵, 阈值=0.8):
    行数, 列数 = np.shape(矩阵)
    for i in range(行数):
        for j in range(列数):
            if float(矩阵[i,j]) > 阈值:
                print(1, end='')
            else:
                print(0, end='')
        print('')

def 图像压缩实验(奇异值保留数=3, 阈值=0.8):
    图像 = []
    for 行 in open('../data/ch14_05.txt').readlines():
        新行 = []
        for i in range(len(行.strip())):
            新行.append(int(行[i]))
        图像.append(新行)
    图像矩阵 = np.mat(图像)
    print("************原始矩阵************")
    二值化打印矩阵(图像矩阵, 阈值)
    输入酉矩阵, 对角奇异值矩阵, 输出酉矩阵 = la.svd(图像矩阵)
    主要奇异值矩阵 = np.mat(np.zeros((奇异值保留数, 奇异值保留数)))
    for k in range(奇异值保留数):#construct diagonal matrix from vector
        主要奇异值矩阵[k,k] = 对角奇异值矩阵[k]
    reconMat = 输入酉矩阵[:,:奇异值保留数]*主要奇异值矩阵*输出酉矩阵[:奇异值保留数,:]
    print("******实用前%d个奇异值重构的矩阵******" %奇异值保留数)
    二值化打印矩阵(reconMat, 阈值)

数据矩阵 = np.mat(载入样例())
推荐序列 = 推荐(数据矩阵, 1, 相似度函数=pearson相似度, 估计函数=奇异值估计)
图像压缩实验(3, 0.5)
# -*- coding: utf-8 -*-
"""
Created on Sun Dec  3 17:42:35 2017
回归树与模型树模板
@author: Burning
"""

import numpy
from numpy import mat

def 加载数据集(文件路径):
    数据集 = []
    文件 = open(文件路径)
    for 行 in 文件.readlines():
        数据集.append(list(map(float, 行.strip().split('\t'))))
    文件.close()
    return mat(数据集)
#默认最后一列标签

def 二分数据矩阵(数据矩阵, 特征维度, 划分值):
    from numpy import nonzero
    大的 = 数据矩阵[nonzero(数据矩阵[:,特征维度] > 划分值)[0], :]
    小的 = 数据矩阵[nonzero(数据矩阵[:,特征维度] <= 划分值)[0], :]
    return 大的, 小的

def 生成叶节点(数据矩阵):
    return numpy.mean(数据矩阵[:,-1])

def 平方误差(数据矩阵):
    return numpy.var(数据矩阵[:,-1]) * numpy.shape(数据矩阵)[0]

def 选择最佳划分(数据矩阵, 叶节点函数=生成叶节点, 损失函数=平方误差, 最少误差下降值=1, 最少切分样本数=4):
    if len(set(数据矩阵[:,-1].T.tolist()[0])) == 1:
        return None, 叶节点函数(数据矩阵)
    from numpy import shape, inf
    特征数 = shape(数据矩阵)[1] - 1
    当前损失 = 损失函数(数据矩阵)
    最小损失 = inf
    for 维度 in range(特征数):
        for 划分值 in set(数据矩阵[:,维度].T.tolist()[0]):
            大的, 小的 = 二分数据矩阵(数据矩阵, 维度, 划分值)
            if shape(大的)[0] < 最少切分样本数 or shape(小的)[0] < 最少切分样本数:
                continue
            新的损失 = 损失函数(大的) + 损失函数(小的)
            if 新的损失 < 最小损失:
                最小损失 = 新的损失
                最佳划分维度 = 维度
                最佳划分值 = 划分值
    if (当前损失 - 最小损失) < 最少误差下降值:
        return None, 叶节点函数(数据矩阵)
    return 最佳划分维度, 最佳划分值

def 构造回归树(数据矩阵, 叶节点函数=生成叶节点, 损失函数=平方误差, 最少误差下降值=1, 最少切分样本数=4):
    划分维度, 划分值 = 选择最佳划分(数据矩阵, 叶节点函数, 损失函数, 最少误差下降值, 最少切分样本数)
    if 划分维度 == None:#这里不能写成if not形式,因为划分维度会为0
        return 划分值
    节点 = dict()
    节点['划分维度'] = 划分维度
    节点['划分值'] = 划分值
    大的, 小的 = 二分数据矩阵(数据矩阵, 划分维度, 划分值)
    节点['大儿子'] = 构造回归树(大的, 叶节点函数, 损失函数, 最少误差下降值, 最少切分样本数)
    节点['小儿子'] = 构造回归树(小的, 叶节点函数, 损失函数, 最少误差下降值, 最少切分样本数)
    print (节点)
    return 节点

def 均值化回归树(回归树):
    if type(回归树['大儿子']) == dict:
        回归树['大儿子'] = 均值化回归树(回归树['大儿子'])
    if type(回归树['小儿子']) == dict:
        回归树['小儿子'] = 均值化回归树(回归树['小儿子'])
    return (回归树['大儿子'] + 回归树['小儿子']) / 2

def 后剪枝(回归树, 测试集):
    from numpy import shape, sum, power
    if not shape(测试集)[0]:
        return 均值化回归树(回归树)
    if type(回归树['大儿子']) == dict or type(回归树['小儿子']) == dict:
        大的, 小的 = 二分数据矩阵(测试集, 回归树['划分维度'], 回归树['划分值'])
    if type(回归树['大儿子']) == dict:
        回归树['大儿子'] = 后剪枝(回归树['大儿子'], 大的)
    if type(回归树['小儿子']) == dict:
        回归树['小儿子'] = 后剪枝(回归树['小儿子'], 小的)
    if type(回归树['大儿子']) != dict and type(回归树['小儿子']) != dict:
        大的, 小的 = 二分数据矩阵(测试集, 回归树['划分维度'], 回归树['划分值'])
        不合并的损失 = sum(power(大的[:,-1] - 回归树['大儿子'], 2)) + sum(power(小的[:,-1] - 回归树['小儿子'], 2))
        均值 = (回归树['大儿子'] + 回归树['小儿子']) / 2
        合并的损失 = sum(power(测试集[:,-1], 2))
        if 合并的损失 < 不合并的损失:
            print ('合并')
            return 均值
    return 回归树

数据矩阵 = 加载数据集('../data/ch09_ex2.txt')
回归树 = 构造回归树(数据矩阵)
print (回归树)
测试矩阵 = 加载数据集('../data/ch09_ex2test.txt')
回归树 = 后剪枝(回归树, 测试矩阵)
print (回归树)